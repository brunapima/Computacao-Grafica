<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL - Múltiplas Visões / Câmeras</title>
  <style>
    html,body{height:100%;margin:0;background:#20232a;color:#eee;font-family:Arial}
    #ui{position:fixed;left:10px;top:10px;background:rgba(0,0,0,0.5);padding:10px;border-radius:6px}
    canvas{display:block;width:100%;height:100vh}
    button{margin-top:6px}
    .kbd{background:#333;padding:2px 6px;border-radius:4px;margin-right:6px}
  </style>
</head>
<body>
  <div id="ui">
    <div><strong>Controles (teclado)</strong></div>
    <div>
      <span class="kbd">1</span> Primeira pessoa (frente)
    </div>
    <div>
      <span class="kbd">2</span> Perspectiva - vista lateral
    </div>
    <div>
      <span class="kbd">3</span> Vista superior (ortográfica)
    </div>
    <div>
      <span class="kbd">4</span> Vista isométrica (ortográfica rotacionada)
    </div>
    <div>
      <span class="kbd">5</span> Camera livre (orbita) - animação automática
    </div>
    <div style="margin-top:8px">Pressione <span class="kbd">Space</span> para pausar / retomar animação</div>
  </div>

  <canvas id="glcanvas"></canvas>

<script>
// Exemplo completo: um cubo simples e múltiplas configurações de câmera.
// A lógica está no escopo principal (evitando muitas funções auxiliares), como solicitado.

const canvas = document.getElementById('glcanvas');
canvas.width = innerWidth;
canvas.height = innerHeight;
const gl = canvas.getContext('webgl');
if(!gl) { alert('WebGL não disponível'); throw new Error('WebGL not supported'); }

// --- shaders simples (cor por vértice) ---
const vsSource = `
attribute vec3 aPosition;
attribute vec3 aColor;
uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;
varying vec3 vColor;
void main(){
  vColor = aColor;
  gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
}`;

const fsSource = `
precision mediump float;
varying vec3 vColor;
void main(){ gl_FragColor = vec4(vColor, 1.0); }
`;

function compileShader(src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}
const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
const prog = gl.createProgram();
gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// --- dados do cubo (positions + cores) ---
const positions = new Float32Array([
  // faces do cubo (36 vertices: 6 faces x 2 tri x 3 verts)
  // Frente
  -1,-1, 1,   1,-1, 1,   1, 1, 1,
  -1,-1, 1,   1, 1, 1,  -1, 1, 1,
  // Trás
  -1,-1,-1,  -1, 1,-1,   1, 1,-1,
  -1,-1,-1,   1, 1,-1,   1,-1,-1,
  // Topo
  -1, 1,-1,  -1, 1, 1,   1, 1, 1,
  -1, 1,-1,   1, 1, 1,   1, 1,-1,
  // Fundo
  -1,-1,-1,   1,-1,-1,   1,-1, 1,
  -1,-1,-1,   1,-1, 1,  -1,-1, 1,
  // Direita
   1,-1,-1,   1, 1,-1,   1, 1, 1,
   1,-1,-1,   1, 1, 1,   1,-1, 1,
  // Esquerda
  -1,-1,-1,  -1,-1, 1,  -1, 1, 1,
  -1,-1,-1,  -1, 1, 1,  -1, 1,-1
]);
// cores por face (cada face tem cor constante)
const faceColors = [
  [1,0,0], // frente - vermelho
  [0,1,0], // trás - verde
  [0,0,1], // topo - azul
  [1,1,0], // fundo - amarelo
  [1,0,1], // direita - magenta
  [0,1,1]  // esquerda - ciano
];
const colors = new Float32Array(36 * 3);
for(let f=0; f<6; ++f){
  for(let v=0; v<6; ++v){
    const idx = (f*6 + v) * 3;
    colors[idx+0] = faceColors[f][0];
    colors[idx+1] = faceColors[f][1];
    colors[idx+2] = faceColors[f][2];
  }
}

// buffers
const posBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(prog, 'aPosition');
gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

const colBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colBuf); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
const colLoc = gl.getAttribLocation(prog, 'aColor');
gl.enableVertexAttribArray(colLoc); gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, 0, 0);

// Uniform locations
const uProjection = gl.getUniformLocation(prog, 'uProjection');
const uView = gl.getUniformLocation(prog, 'uView');
const uModel = gl.getUniformLocation(prog, 'uModel');

// --- pequenas utilidades de matriz (mat4) ---
// Implementações diretas e simples: perspective, ortho, lookAt, multiply
function degToRad(d){ return d * Math.PI / 180; }
function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
function mat4Multiply(a,b){
  const r = new Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      r[j*4+i] = 0;
      for(let k=0;k<4;k++) r[j*4+i] += a[k*4+i]*b[j*4+k];
    }
  }
  return r;
}
function mat4Translation(tx,ty,tz){ const m=mat4Identity(); m[12]=tx; m[13]=ty; m[14]=tz; return m; }
function mat4RotateY(a){ const c=Math.cos(a), s=Math.sin(a); return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]; }
function mat4Scale(sx,sy,sz){ const m=mat4Identity(); m[0]=sx; m[5]=sy; m[10]=sz; return m; }
function mat4Perspective(fovy, aspect, near, far){
  const f = 1.0 / Math.tan(fovy/2);
  const nf = 1/(near - far);
  const out = new Array(16).fill(0);
  out[0] = f / aspect;
  out[5] = f;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[14] = (2 * far * near) * nf;
  return out;
}
function mat4Ortho(l, r, b, t, near, far){
  const out = new Array(16).fill(0);
  out[0] = 2/(r-l); out[5] = 2/(t-b); out[10] = -2/(far-near);
  out[12] = -(r+l)/(r-l); out[13] = -(t+b)/(t-b); out[14] = -(far+near)/(far-near); out[15]=1;
  return out;
}
function normalize(v){ const n=Math.hypot(v[0],v[1],v[2]); return [v[0]/n,v[1]/n,v[2]/n]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function mat4LookAt(eye, center, up){
  const z = normalize([eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]]);
  const x = normalize(cross(up, z));
  const y = cross(z, x);
  const out = mat4Identity();
  out[0]=x[0]; out[4]=x[1]; out[8]=x[2];
  out[1]=y[0]; out[5]=y[1]; out[9]=y[2];
  out[2]=z[0]; out[6]=z[1]; out[10]=z[2];
  out[12]=-(x[0]*eye[0]+x[1]*eye[1]+x[2]*eye[2]);
  out[13]=-(y[0]*eye[0]+y[1]*eye[1]+y[2]*eye[2]);
  out[14]=-(z[0]*eye[0]+z[1]*eye[1]+z[2]*eye[2]);
  return out;
}

// --- Lista de câmeras (configurações) ---
// Cada câmera é um objeto com: type ('persp'|'ortho'), params e uma função para gerar view/projection.
const cams = [
  // 0: primeira pessoa - posição próxima, perspectiva
  { name:'Primeira pessoa', type:'persp', pos:[0,0,5], center:[0,0,0], fovy:degToRad(60) },
  // 1: lateral - perspectiva com ângulo baixo
  { name:'Lateral', type:'persp', pos:[5,1.5,0], center:[0,0,0], fovy:degToRad(50) },
  // 2: top-down ortográfica
  { name:'Top-down', type:'ortho', pos:[0,6,0], center:[0,0,0], size:4 },
  // 3: isométrica (ortho rotacionada)
  { name:'Isométrica', type:'ortho', pos:[4,4,4], center:[0,0,0], size:4 },
  // 4: orbit - usada para animação
  { name:'Orbit', type:'persp', pos:[6,2,0], center:[0,0,0], fovy:degToRad(45) }
];

let activeIndex = 0; // câmera atual mostrada
let animEnabled = true; // animação global ligada
let orbitAngle = 0; // ângulo usado pela câmera 4 (orbit)

// função para obter matrizes view e projection a partir de câmera e aspect
function getMatrices(cam, aspect){
  let proj;
  let view;
  if(cam.type === 'persp'){
    proj = mat4Perspective(cam.fovy, aspect, 0.1, 100.0);
    view = mat4LookAt(cam.pos, cam.center, [0,1,0]);
  } else {
    const s = cam.size || 4;
    proj = mat4Ortho(-s*aspect, s*aspect, -s, s, -50, 50);
    view = mat4LookAt(cam.pos, cam.center, [0,1,0]);
  }
  return { view, proj };
}

// Model: rotação lenta do cubo
let cubeRot = 0;

// Evento teclado para trocar câmeras e controlar animação
window.addEventListener('keydown', (e)=>{
  if(e.code === 'Space'){ animEnabled = !animEnabled; }
  if(e.key >= '1' && e.key <= '5'){
    activeIndex = parseInt(e.key)-1;
    // reset orbit angle if selecionou orbit
    if(activeIndex === 4) orbitAngle = 0;
  }
});

// resize handling
window.addEventListener('resize', ()=>{ canvas.width = innerWidth; canvas.height = innerHeight; gl.viewport(0,0,canvas.width,canvas.height); });
gl.viewport(0,0,canvas.width,canvas.height);

// estados para transição animada entre câmeras (interp. simples)
let transition = { active:false, fromIdx:0, toIdx:0, t:0, duration:0.6 };
function startTransition(toIdx){ transition.active=true; transition.fromIdx=activeIndex; transition.toIdx=toIdx; transition.t=0; activeIndex = toIdx; }

// Para uma transição mais suave entre duas câmeras, interpolamos posição e size/fovy
function interp(a,b,t){ return a*(1-t) + b*t; }

// Render loop
function render(now){
  now *= 0.001; // s
  const aspect = canvas.width / canvas.height;

  if(animEnabled){
    cubeRot += 0.6 * 0.016; // rotação do cubo
    if(activeIndex === 4){ orbitAngle += 0.6 * 0.016; cams[4].pos = [6*Math.cos(orbitAngle), 2 + Math.sin(orbitAngle)*0.5, 6*Math.sin(orbitAngle)]; }
  }

  // transição entre câmeras (se houver)
  // OBS: transição é iniciada somente por startTransition (neste exemplo não chamada automaticamente),
  // mas o código abaixo demonstra como interpolar caso queira ligar a transition.
  if(transition.active){
    transition.t += 0.016 / transition.duration;
    if(transition.t >= 1){ transition.active=false; transition.t=1; }
    // interpolando pos e parâmetros básicos (fovy/size)
    const from = cams[transition.fromIdx];
    const to = cams[transition.toIdx];
    const t = transition.t;
    const interpPos = [interp(from.pos[0], to.pos[0], t), interp(from.pos[1], to.pos[1], t), interp(from.pos[2], to.pos[2], t)];
    const interpCenter = [interp(from.center[0], to.center[0], t), interp(from.center[1], to.center[1], t), interp(from.center[2], to.center[2], t)];
    const fakeCam = { type: to.type, pos: interpPos, center: interpCenter, fovy: (from.fovy || degToRad(45))*(1-t) + (to.fovy || degToRad(45))*t, size: (from.size||4)*(1-t) + (to.size||4)*t };
    const m = getMatrices(fakeCam, aspect);
    gl.uniformMatrix4fv(uProjection, false, new Float32Array(m.proj));
    gl.uniformMatrix4fv(uView, false, new Float32Array(m.view));
  } else {
    // câmera ativa normal
    const cam = cams[activeIndex];
    const m = getMatrices(cam, aspect);
    gl.uniformMatrix4fv(uProjection, false, new Float32Array(m.proj));
    gl.uniformMatrix4fv(uView, false, new Float32Array(m.view));
  }

  // model: rotação do cubo
  const model = mat4Multiply(mat4RotateY(cubeRot), mat4Scale(1,1,1));
  gl.uniformMatrix4fv(uModel, false, new Float32Array(model));

  // limpar e desenhar
  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.12,0.12,0.13,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLES, 0, 36);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// Mensagem simples no console com instruções
console.log('Teclas: 1..5 trocam câmeras. Space pausa/retoma animação.');

</script>
</body>
</html>
